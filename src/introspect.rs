use crate::{BuildContext, BuildOptions, PythonInterpreter};
use anyhow::{Context, Result};
use libloading::{Library, Symbol};
use std::ffi::{c_char, CString};
use std::path::Path;

/// Introspects stubs autogenerated by PyO3 in the built dynamic libraries
pub fn introspect_stubs(build_options: BuildOptions) -> Result<String> {
    let build_context = build_options.into_build_context(false, false, false)?;
    let mut errors = Vec::new();
    for interpreter in &build_context.interpreter {
        match introspect_with_interpreter(&build_context, interpreter) {
            Ok(stubs) => {
                return Ok(stubs);
            }
            Err(e) => errors.push(e),
        }
    }
    Err(errors
        .pop()
        .context("No interpreter found to introspect the library")?
        .context("Failed to introspect the library"))
}

fn introspect_with_interpreter(
    build_context: &BuildContext,
    interpreter: &PythonInterpreter,
) -> Result<String> {
    load_dynamic_library(&interpreter.executable)?;
    let artifact = build_context.compile_cdylib(
        Some(interpreter),
        Some(&build_context.project_layout.extension_name),
    )?;
    for linked in &artifact.linked_paths {
        load_dynamic_library(Path::new(linked))?;
    }
    find_stub_in_dynamic_library(&artifact.path, &build_context.project_layout.extension_name)
}

fn load_dynamic_library(path: &Path) -> Result<Library> {
    unsafe { Library::new(path).with_context(|| format!("Failed to load {}", path.display())) }
}

fn find_stub_in_dynamic_library(library_path: &Path, extension_name: &str) -> Result<String> {
    unsafe {
        let lib = load_dynamic_library(library_path)?;
        let func: Symbol<unsafe extern "C" fn() -> *mut c_char> = lib
            .get(format!("__pyo3_stubs_{extension_name}").as_bytes())
            .context("No stubs found in the compiled library")?;
        CString::from_raw(func())
            .into_string()
            .context("Failed to load stubs")
    }
}
